# React Admin Amplify

AWS Amplify data provider for [react-admin](https://github.com/marmelab/react-admin).

- [Installation](#installation)
- [Usage](#usage)
- [Options](#options)
- [Features](#features)

This library contains the data and auth providers that connect a [react-admin](https://github.com/marmelab/react-admin) frontend to an [Amplify](https://docs.amplify.aws) backend. It also includes some components that make things easier to set up.

A demo is available here: <https://dev.d10isjcm6q3oja.amplifyapp.com>. It demonstrates the use of this library with the [17 patterns GraphQL schema](https://docs.amplify.aws/cli/graphql-transformer/dataaccess).

Demo source code is here: <https://github.com/MrHertal/react-admin-amplify-demo>.

## How does it work

The data provider accepts GraphQL queries and mutations as parameters.
Queries and mutations are the one generated by the [Amplify CLI](https://docs.amplify.aws/cli/graphql-transformer/codegen).

Based on the resource that is required, the data provider is able to choose the right query and to fetch the data.
GraphQL queries are executed with the [Amplify GraphQL client](https://docs.amplify.aws/lib/graphqlapi/query-data/q/platform/js).

On the other hand, the auth provider uses the [Amplify Auth library](https://docs.amplify.aws/lib/auth/emailpassword/q/platform/js) to manage users sign-in and sign-out.

## Before installation

Please note that your Amplify backend, meaning the `amplify/` folder containing your GraphQL schema, can be located in a different repo than the react-admin one.

Starting from a react-admin project, install the API and Auth libraries:

```sh
npm install @aws-amplify/core @aws-amplify/api @aws-amplify/auth
```

You will need the configuration file `aws-exports.js` of your Amplify backend, so that react-admin can connect to your API.

Finally, you will need the `queries.js` and `mutations.js` files generated by the [Amplify CLI](https://docs.amplify.aws/cli/graphql-transformer/codegen).

## Installation

```sh
npm install react-admin-amplify
```

## Usage

Simplest way to set things up is to use the `AdminAmplify` component:

```jsx
// in App.js
import { Amplify } from "@aws-amplify/core";
import React from "react";
import { Resource } from "react-admin";
import { AmplifyAdmin } from "react-admin-amplify";
import awsExports from "./aws-exports";
import * as mutations from "./graphql/mutations";
import * as queries from "./graphql/queries";

Amplify.configure(awsExports); // Configure Amplify the usual way

function App() {
  return (
    <AmplifyAdmin // Replace the Admin component of react-admin
      operations={{ queries, mutations }} // Pass the queries and mutations
      options={{ authGroups: ["admin"] }} // Pass the options
    >
      <Resource name="orders" />{/* Set the resources as you would do within Admin component */}
    </AmplifyAdmin>
  );
}

export default App;
```

Data and auth providers can also be set independantly using `buildDataProvider` or `buildAuthProvider`.

Code above is actually the equivalent of:

```jsx
// in App.js
import { Amplify } from "@aws-amplify/core";
import React, { useEffect, useState } from "react";
import { Admin, Resource } from "react-admin";
import { buildAuthProvider, buildDataProvider } from "react-admin-amplify";
import awsExports from "./aws-exports";
import * as mutations from "./graphql/mutations";
import * as queries from "./graphql/queries";

Amplify.configure(awsExports);

function App() {
  const [authProvider, setAuthProvider] = useState(null);
  const [dataProvider, setDataProvider] = useState(null);

  useEffect(() => {
    const provider = buildAuthProvider({ authGroups: ["admin"] });

    setAuthProvider(() => provider);
  }, []);

  useEffect(() => {
    const provider = buildDataProvider({ queries, mutations });

    setDataProvider(() => provider);
  }, []);

  if (!authProvider || !dataProvider) {
    return <div>Loading</div>;
  }

  return (
    <Admin authProvider={authProvider} dataProvider={dataProvider}>
      <Resource name="orders" />
    </Admin>
  );
}

export default App;
```

## Options

### Auth provider

`authGroups`: array of user groups. Default: `[]`

Restrict access of your react-admin app to users belonging to one of these groups.

For example:

`authGroups: ["admin"]` - only users belonging to Cognito group `admin` will be able to sign in.

### Data provider

`authMode`: string. Default: `AMAZON_COGNITO_USER_POOLS`

Authorization mode used by the Amplify GraphQL client.

### AmplifyAdmin

`AmplifyAdmin` component only accepts the `authGroups` option, that is passed to the auth provider.

## Features

This section details some features of the library but also some limitations.

### Pagination

Total count is not supported by Amplify, see <https://github.com/aws-amplify/amplify-cli/issues/1865>.

That means that react-admin default pagination does not suit well. I suggest implementing a prev/next pagination like the one described in react-admin [documentation](https://marmelab.com/react-admin/List.html#pagination).

Alternatively, you can use the pagination of the [demo](https://github.com/MrHertal/react-admin-amplify-demo/blob/master/src/components/Pagination.js). It is basically the same as the react-admin default pagination, except it does not display total count.

### Filter

In order to use react-admin filters, you will have to correctly set [@key directives](https://docs.amplify.aws/cli/graphql-transformer/directives#key) in your schema.

Let's say you have a GraphQL schema that defines a type `Order`:

```graphql
type Order @model
{
  id: ID!
  customerID: ID!
  accountRepresentativeID: ID!
  productID: ID!
  status: String!
  amount: Int!
  date: String!
}
```

To list orders in react-admin, you define a resource called `orders`:

```jsx
<Resource name="orders" list={OrderList} />
```

Data provider will execute the query `listOrders` by default, when no filters are applied:

```js
export const listOrders = /* GraphQL */ `
  query ListOrders(
    $filter: ModelOrderFilterInput
    $limit: Int
    $nextToken: String
  ) {
    listOrders(filter: $filter, limit: $limit, nextToken: $nextToken) {
      items {
        id
        customerID
        accountRepresentativeID
        productID
        status
        amount
        date
        createdAt
        updatedAt
      }
      nextToken
    }
  }
`;
```

Now you want to filter orders by product. You may think about passing a `$filter` argument to that query. Unfortunately, this would only filter the results after query has been executed.

You need to configure index structures in order to do that, using the `@key` directive:

```graphql
type Order @model
  @key(name: "byProduct", fields: ["productID", "id"], queryField: "ordersByProduct")
{
  id: ID!
  customerID: ID!
  accountRepresentativeID: ID!
  productID: ID!
  status: String!
  amount: Int!
  date: String!
}
```

Amplify CLI will generate the query `ordersByProduct`:

```js
export const ordersByProduct = /* GraphQL */ `
  query OrdersByProduct(
    $productID: ID
    $id: ModelIDKeyConditionInput
    $sortDirection: ModelSortDirection
    $filter: ModelOrderFilterInput
    $limit: Int
    $nextToken: String
  ) {
    ordersByProduct(
      productID: $productID
      id: $id
      sortDirection: $sortDirection
      filter: $filter
      limit: $limit
      nextToken: $nextToken
    ) {
      items {
        id
        customerID
        accountRepresentativeID
        productID
        status
        amount
        date
        createdAt
        updatedAt
      }
      nextToken
    }
  }
`;
```

Finally in your react-admin app, set the filter this way:

```jsx
const OrderFilter = (props) => (
  <Filter {...props}>
    <TextInput source="ordersByProduct.productID" label="Product id" alwaysOn resettable />
  </Filter>
);
```

The source `ordersByProduct.productID` tells the data provider to execute `ordersByProduct` query, passing filter value as `productID` parameter.

### AmplifyFilter

Things become more complex when you want to add several filters.

Let's say that you want to add another filter to the order resource. You want to be able to filter orders by customer and by date:

```graphql
type Order @model
  @key(name: "byProduct", fields: ["productID", "id"], queryField: "ordersByProduct")
  @key(name: "byCustomerByDate", fields: ["customerID", "date"], queryField: "ordersByCustomerByDate")
{
  id: ID!
  customerID: ID!
  accountRepresentativeID: ID!
  productID: ID!
  status: String!
  amount: Int!
  date: String!
}
```

In your react-admin app, filters are set this way:

```jsx
const OrderFilter = (props) => (
  <Filter {...props}>
    <TextInput source="ordersByProduct.productID" label="Product id" alwaysOn resettable />
    <TextInput source="ordersByCustomerByDate.customerID" label="Customer id" alwaysOn resettable />
    <DateInput source="ordersByCustomerByDate.date.eq" label="Date" alwaysOn />
  </Filter>
);
```

Please note that `date` field is a sort key, so you need to specify an operator to the query (`eq` in this example).

These filters may be confusing for the users because they would expect to filter orders by product, customer and date at the same time.
In fact, you need to hide product filter when customer filter is being used, because the query executed is `ordersByCustomerByDate` and not `ordersByProduct`.

`AmplifyFilter` component solves this issue by displaying or hiding filters automatically:

```jsx
import { AmplifyFilter } from "react-admin-amplify";

const OrderFilter = (props) => (
  <AmplifyFilter {...props}>
    <TextInput source="ordersByProduct.productID" label="Product id" alwaysOn resettable />
    <TextInput source="ordersByCustomerByDate.customerID" label="Customer id" alwaysOn resettable />
    <DateInput source="ordersByCustomerByDate.date.eq" label="Date" alwaysOn />
  </AmplifyFilter>
);
```

Check the demo to see it in action: <https://dev.d10isjcm6q3oja.amplifyapp.com>.

Demo source code is here: <https://github.com/MrHertal/react-admin-amplify-demo>.

### Sorting

Sorting data is possible with the sort key. Since default list queries (like `listOrders`) have no sort key, you cannot sort them.
Similarly to filters, sorting is therefore based on [@key directives](https://docs.amplify.aws/cli/graphql-transformer/directives#key) set in the GraphQL schema.

Let's look at `Order` schema again:

```graphql
type Order @model
  @key(name: "byProduct", fields: ["productID", "id"], queryField: "ordersByProduct")
  @key(name: "byCustomerByDate", fields: ["customerID", "date"], queryField: "ordersByCustomerByDate")
{
  id: ID!
  customerID: ID!
  accountRepresentativeID: ID!
  productID: ID!
  status: String!
  amount: Int!
  date: String!
}
```

With such a configuration, sorting by `id` is possible only when filtering orders by product, whereas sorting by date is only possible when filtering orders by customer.

In order to tell your react-admin app, you have to specify the query name in the `sortBy` prop:

```jsx
export const OrderList = (props) => {
  return (
    <List {...props} filters={<OrderFilter />}>
      <Datagrid>
        <TextField source="id" sortBy="ordersByProduct" sortable={true} />
        <DateField source="date" sortBy="ordersByCustomerByDate" sortable={true} />
      </Datagrid>
    </List>
  );
};
);
```

Just like filters, it is better for users to only allow sorting when it is available. To do that, you have to change dynamically the `sortable` prop, depending on the filter that is applied.

See a working example [on the demo](https://github.com/MrHertal/react-admin-amplify-demo/blob/master/src/components/Order.js).

## TODO

This section is a short list of what could be done to improve this library.

### Admin queries API

Manage Cognito users within react-admin, using the [admin queries API](https://docs.amplify.aws/cli/auth/admin).

### DataStore

Using DataStore instead of API library could bring offline capabilities to the react-admin app.

### @searchable directive

The `@searchable` directive is not yet compatible with the data provider.
